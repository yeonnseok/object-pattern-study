# chapter2 객체지향
## 1. 절차지향과 객체지향
### 절차지향(Procedural Oriented) 프로그래밍
절차지향 프로그래밍은 다수의 프로시저들이 데이터를 공유하는 방식으로
만들어 지기 때문에, 절차 지향 프로그램은 자연스럽게 데이터를 중심으로
구현하게 된다.

#### 절차지향 프로그래밍의 문제점
* 데이터 타입이나 의미를 변경해야 할 때, 함께 수정해야 하는 프로시저가 증가한다.
    * 데이터가 여러 프로시저에 흩어져서 사용되기 때문에 수정 시 사용되는 모든 
    프로시저를 변경해야 한다.
* 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생한다.
    * 예시 ) 서비스 만료일 데이터를 확인하고자 null 값을 설정하고
    만료일을 검사하는 프로시저를 만들었는데, 다른 프로시저에서 서비스를
    무한정 사용한다는 의미로 null 값을 쓸 수도 있다.
    
### 객체지향(Object Oriented) 프로그래밍
객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에는
영향을 주지 않기 때문에, 변화된 요구사항을 빠르고 쉽게 반영할 수 있다는
장점이 있다.

---
## 2. 객체 (Object)
### 객체의 핵심은 기능을 제공하는 것
예를 들어 소리 크기 제어 객체가 있다고 가정했을 때, 이 객체를 정의할 때
필요한 것은 객체가 제공해야할 기능이다. 해당 기능을 구현하는데 
어떤 데이터가 필요하는지는 외부에서 궁금하지 않다.

* 소리 크기 증가
* 소리 크기 감소
* 음소거

### 인터페이스와 클래스
위와 같이 객체가 제공하는 기능 즉, 오퍼레이션의 집합을 `인터페이스`
라고 부른다. 서로 다른 인터페이스는 `타입`으로 구분한다.
객체가 제공하는 기능은 오퍼레이션이라고 부르고 각 오퍼레이션은
일반적으로 아래 세 개로 구성되며 이 세가지를 합쳐서 `시그니처`라고 
부른다.

* 기능 식별 이름
* 파라미터 및 파라미터 타입
* 기능 실행 결과 값

### 메시지
객체 지향은 여러 객체들이 서로 협력하여 하나의 완성된 기능을 제공하는
어플리케이션을 구성하게 된다. 객체들은 서로 협력할 때 `메시지`를 통해
연결 된다. 메시지는 객체가 가지고 있는 오퍼레이션을 요청하는 것으로
객체의 퍼블릭 인터페이스에 있는 메서드를 호출함으로써 메시지를 보낸다.

---
## 3. 객체의 책임과 크기
객체는 객체가 제공하는 기능으로 정의되는데, 다시 말하면 객체마다 자신만의
책임(responsibility)이 있다는 의미이다.
한 객체가 갖는 책임을 정의한 것이 바로 `타입/인터페이스`이고 이것을 결정하는
것이 객체지향 설계의 출발점이다.

> 책임을 주도로 객체를 설계하면 더욱 추상적인 인터페이스 추출이 가능하고
이는 다형성과 확장을 대비한 유연한 설계가 가능해진다. 

#### 단일 책임 원칙(Single Responsibility Principle)
객체는 하나의 책임만을 가져야 한다.
객체가 갖는 책임이 커질수록 절차 지향적으로 구조가 변질되며
변경의 어려움이 수반된다.

---
## 4. 의존
한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그
객체에 의존(dependency)한다고 표현한다.
객체를 생성하거나 호출하는 것뿐만 아니라 파라미터로 전달받는 경우에도
의존한다고 볼 수 있다.
> 다른 타입에 의존한다는 것은 의존하는 타입에 변경이 발생할 때 나도
함께 변경될 가능성이 높다는 것을 의미한다.

#### 순환의존
C 클래스가 B 클래스에 의존하고 B 클래스가 A 클래스에 의존한다고 했을 때, 
A 클래스에 변겨잉 생기면 B 클래스, C 클래스까지 영향을 주게 되고,
변경의 여파가 다시 A 클래스까지 돌아올 수 있다.
이를 해결하기 위해서 `의존성 역전 원칙(Dependency Inversion Principle)`
을 사용한다. (추후 다시 나옴)

#### 의존의 양면성
A 클래스가 B 클래스를 의존하고 있다면 B 클래스에 변경이 생길때 
A 클래스도 영향을 받게 된다. 하지만 A 클래스의 요구가 변경된다면
그에 맞게 B 클래스도 다시 변화가 발생한다. 
이는 의존이 상호간에 영향을 준다는 것을 의미한다.

---
## 5. 캡슐화
### 캡슐화를 통해 구현 변경의 유연성 획득
캡슐화(encapsulation)는 객체가 내부적으로 기능을 어떻게 구현하는지를
감추는 것이다.
**기능 구현을 캡슐화하게 되면, 내부 구현이 변경되더라도 
기능을 사용하는 곳의 영향을 최소화할 수 있다.**

### 캡슐화를 위한 두 개의 규칙
#### Tell, Don't Ask
* 데이터를 물어보지 않고 기능을 실행해 달라고 말한다.

#### 디미터의 법칙(Law of Demeter)
* 메서드에서 생성한 객체의 메서드만 호출
* 파라미터로 받은 객체의 메서드만 호출
* 필드로 참조하는 객체의 메서드만 호출

> 위 두 규칙을 지키면 도메인 객체간에 getter 를 호출할 필요가 없어진다.

---
## 6. 객체 지향 설계 과정
1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에
할당한다.
    * 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를
    먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다.
    * 기능은 최대한 캡슐화해서 구현한다.
2. 객체 간에 어떻게 메시지를 주고 받을 지 결정한다.
3. 개발하는 동안 과정1과 과정2를 지속적으로 반복한다.

> 객체 설계는 한 번에 완성되지 않고 구현을 진행해 나가면서 점진적으로 완성된다.
> 이는 최초의 설계가 완벽하지 않으며, 개발이 진행되면서 설계도 함께 변경된다는 것을
> 의미한다. 따라서 설계를 할 때는 변경되는 부분을 고려한 유연한 구조를 
> 갖도록 노력해야 한다. 

> 이번 장에서 살펴본 캡슐화는 내부 구현에 대해 유연함을 제공해 주는 기법이라고 할 수 있다.

